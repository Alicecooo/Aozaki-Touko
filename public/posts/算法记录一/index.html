<!doctype html><html lang=en dir=auto data-theme=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>算法记录(一) | Aozaki Touko</title><meta name=keywords content="CS"><meta name=description content="前置
定长

定长处理比较容易，不用关心窗口的大小，只用针对满足特定数组的条件进行处理判断。
主要的思路如下：
窗口右端点在 i 时，由于窗口长度为 k，所以窗口左端点为 i−k+1。

三步：入-更新-出。
入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1<0，则尚未形成第一个窗口，重复第一步。
更新：更新答案。
出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。



不定长


不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。


求最长子数组和最短子数组，还是入——更新——出，三步走。不过会略有不同。

更新：下标为 i 的元素进入。如果满足条件，加入，重复，继续扩大，直到遇到不合适情况。
出：下标为 left 的元素离开窗口，left++ ，记录此时带窗口大小 i-left+1，为下一个循环做准备。



求子数组个数

越短越合法
一般要写 ans += right - left + 1。内层循环结束后，[left, right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left, right]，还有 [left+1, right],[left+2, right],…,[right, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left, left+1, left+2,…, right 的所有子数组都是满足要求的，这一共有 right−left+1 个。
越长越合法
一般要写 ans += left。内层循环结束后，[left, right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1, right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1, right]，还有 [left−2, right],[left−3, right],…,[0, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…, left−1 的所有子数组都是满足要求的，这一共有 left 个。我们关注的是 left−1 的合法性，而不是 left。



恰好型滑动"><meta name=author content="Alicecooo"><link rel=canonical href=http://localhost:1313/posts/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E4%B8%80/><link crossorigin=anonymous href=/assets/css/stylesheet.dc8af9689020a8f41687e01bb280d297f5e3e6227a7ea8db0cb3b656ba3d49f0.css integrity="sha256-3Ir5aJAgqPQWh+AbsoDSl/Xj5iJ6fqjbDLO2Vro9SfA=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E4%B8%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="http://localhost:1313/posts/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E4%B8%80/"><meta property="og:site_name" content="Aozaki Touko"><meta property="og:title" content="算法记录(一)"><meta property="og:description" content="前置 定长 定长处理比较容易，不用关心窗口的大小，只用针对满足特定数组的条件进行处理判断。 主要的思路如下： 窗口右端点在 i 时，由于窗口长度为 k，所以窗口左端点为 i−k+1。 三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1<0，则尚未形成第一个窗口，重复第一步。 更新：更新答案。 出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。 不定长 不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。
求最长子数组和最短子数组，还是入——更新——出，三步走。不过会略有不同。
更新：下标为 i 的元素进入。如果满足条件，加入，重复，继续扩大，直到遇到不合适情况。 出：下标为 left 的元素离开窗口，left++ ，记录此时带窗口大小 i-left+1，为下一个循环做准备。 求子数组个数
越短越合法 一般要写 ans += right - left + 1。内层循环结束后，[left, right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left, right]，还有 [left+1, right],[left+2, right],…,[right, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left, left+1, left+2,…, right 的所有子数组都是满足要求的，这一共有 right−left+1 个。 越长越合法 一般要写 ans += left。内层循环结束后，[left, right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1, right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1, right]，还有 [left−2, right],[left−3, right],…,[0, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…, left−1 的所有子数组都是满足要求的，这一共有 left 个。我们关注的是 left−1 的合法性，而不是 left。 恰好型滑动"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-20T15:15:32+08:00"><meta property="article:modified_time" content="2026-01-20T15:15:32+08:00"><meta property="article:tag" content="CS"><meta name=twitter:card content="summary"><meta name=twitter:title content="算法记录(一)"><meta name=twitter:description content="前置
定长

定长处理比较容易，不用关心窗口的大小，只用针对满足特定数组的条件进行处理判断。
主要的思路如下：
窗口右端点在 i 时，由于窗口长度为 k，所以窗口左端点为 i−k+1。

三步：入-更新-出。
入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1<0，则尚未形成第一个窗口，重复第一步。
更新：更新答案。
出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。



不定长


不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。


求最长子数组和最短子数组，还是入——更新——出，三步走。不过会略有不同。

更新：下标为 i 的元素进入。如果满足条件，加入，重复，继续扩大，直到遇到不合适情况。
出：下标为 left 的元素离开窗口，left++ ，记录此时带窗口大小 i-left+1，为下一个循环做准备。



求子数组个数

越短越合法
一般要写 ans += right - left + 1。内层循环结束后，[left, right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left, right]，还有 [left+1, right],[left+2, right],…,[right, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left, left+1, left+2,…, right 的所有子数组都是满足要求的，这一共有 right−left+1 个。
越长越合法
一般要写 ans += left。内层循环结束后，[left, right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1, right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1, right]，还有 [left−2, right],[left−3, right],…,[0, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…, left−1 的所有子数组都是满足要求的，这一共有 left 个。我们关注的是 left−1 的合法性，而不是 left。



恰好型滑动"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"算法记录(一)","item":"http://localhost:1313/posts/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E4%B8%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"算法记录(一)","name":"算法记录(一)","description":"前置 定长 定长处理比较容易，不用关心窗口的大小，只用针对满足特定数组的条件进行处理判断。 主要的思路如下： 窗口右端点在 i 时，由于窗口长度为 k，所以窗口左端点为 i−k+1。 三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1\u0026lt;0，则尚未形成第一个窗口，重复第一步。 更新：更新答案。 出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。 不定长 不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。\n求最长子数组和最短子数组，还是入——更新——出，三步走。不过会略有不同。\n更新：下标为 i 的元素进入。如果满足条件，加入，重复，继续扩大，直到遇到不合适情况。 出：下标为 left 的元素离开窗口，left++ ，记录此时带窗口大小 i-left+1，为下一个循环做准备。 求子数组个数\n越短越合法 一般要写 ans += right - left + 1。内层循环结束后，[left, right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left, right]，还有 [left+1, right],[left+2, right],…,[right, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left, left+1, left+2,…, right 的所有子数组都是满足要求的，这一共有 right−left+1 个。 越长越合法 一般要写 ans += left。内层循环结束后，[left, right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1, right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1, right]，还有 [left−2, right],[left−3, right],…,[0, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…, left−1 的所有子数组都是满足要求的，这一共有 left 个。我们关注的是 left−1 的合法性，而不是 left。 恰好型滑动\n","keywords":["CS"],"articleBody":"前置 定长 定长处理比较容易，不用关心窗口的大小，只用针对满足特定数组的条件进行处理判断。 主要的思路如下： 窗口右端点在 i 时，由于窗口长度为 k，所以窗口左端点为 i−k+1。 三步：入-更新-出。 入：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1\u003c0，则尚未形成第一个窗口，重复第一步。 更新：更新答案。 出：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。 不定长 不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。\n求最长子数组和最短子数组，还是入——更新——出，三步走。不过会略有不同。\n更新：下标为 i 的元素进入。如果满足条件，加入，重复，继续扩大，直到遇到不合适情况。 出：下标为 left 的元素离开窗口，left++ ，记录此时带窗口大小 i-left+1，为下一个循环做准备。 求子数组个数\n越短越合法 一般要写 ans += right - left + 1。内层循环结束后，[left, right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left, right]，还有 [left+1, right],[left+2, right],…,[right, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left, left+1, left+2,…, right 的所有子数组都是满足要求的，这一共有 right−left+1 个。 越长越合法 一般要写 ans += left。内层循环结束后，[left, right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1, right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1, right]，还有 [left−2, right],[left−3, right],…,[0, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…, left−1 的所有子数组都是满足要求的，这一共有 left 个。我们关注的是 left−1 的合法性，而不是 left。 恰好型滑动\n维度 （至多≤） （至少≥） 函数目标 统计和≤x 的子数组数 统计和≥x 的子数组数 相减逻辑 用 “相邻小范围” 抠除（k 和 k-1） 用 “相邻大范围” 抠除（k 和 k+1） 窗口收缩条件 sum \u003e x（保证窗口内 sum≤x） sum ≥x（收缩到 sum","wordCount":"788","inLanguage":"en","datePublished":"2026-01-20T15:15:32+08:00","dateModified":"2026-01-20T15:15:32+08:00","author":{"@type":"Person","name":"Alicecooo"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95%E4%B8%80/"},"publisher":{"@type":"Organization","name":"Aozaki Touko","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Aozaki Touko (Alt + H)">Aozaki Touko</a><div class=logo-switches></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Home><span>Home</span></a></li><li><a href=http://localhost:1313/archives/ title=Archives><span>Archives</span></a></li><li><a href=http://localhost:1313/tags/ title=Tag><span>Tag</span></a></li><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">算法记录(一)</h1><div class=post-meta><span title='2026-01-20 15:15:32 +0800 CST'>January 20, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>788 words</span>&nbsp;·&nbsp;<span>Alicecooo</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%89%8d%e7%bd%ae aria-label=前置>前置</a><ul><li><a href=#%e5%ae%9a%e9%95%bf aria-label=定长>定长</a></li><li><a href=#%e4%b8%8d%e5%ae%9a%e9%95%bf aria-label=不定长>不定长</a></li></ul></li><li><a href=#%e8%ae%b0%e5%bd%95 aria-label=记录>记录</a><ul><li><a href=#%e5%ae%9a%e9%95%bf%e5%a4%84%e7%90%86 aria-label=定长处理>定长处理</a></li><li><a href=#%e4%b8%8d%e5%ae%9a%e9%95%bf-1 aria-label=不定长>不定长</a><ul><li><a href=#%e6%b1%82%e6%9c%80%e9%95%bf aria-label=求最长>求最长</a></li><li><a href=#%e6%b1%82%e6%9c%80%e7%9f%ad aria-label=求最短>求最短</a></li><li><a href=#%e6%b1%82%e5%ad%90%e6%95%b0%e7%bb%84%e4%b8%aa%e6%95%b0 aria-label=求子数组个数>求子数组个数</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=前置>前置<a hidden class=anchor aria-hidden=true href=#前置>#</a></h1><h2 id=定长>定长<a hidden class=anchor aria-hidden=true href=#定长>#</a></h2><ul><li>定长处理比较容易，不用关心窗口的大小，只用针对满足特定数组的条件进行处理判断。</li><li>主要的思路如下：</li><li>窗口右端点在 i 时，由于窗口长度为 k，所以窗口左端点为 i−k+1。<ul><li><strong>三步：入-更新-出。</strong></li><li><strong>入</strong>：下标为 i 的元素进入窗口，更新相关统计量。如果窗口左端点 i−k+1&lt;0，则尚未形成第一个窗口，重复第一步。</li><li><strong>更新</strong>：更新答案。</li><li><strong>出</strong>：下标为 i−k+1 的元素离开窗口，更新相关统计量，为下一个循环做准备。</li></ul></li></ul><h2 id=不定长>不定长<a hidden class=anchor aria-hidden=true href=#不定长>#</a></h2><ul><li><p>不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，求子数组个数。</p></li><li><p>求最长子数组和最短子数组，还是入——更新——出，三步走。不过会略有不同。</p><ul><li>更新：下标为 i 的元素进入。如果满足条件，加入，重复，继续扩大，直到遇到不合适情况。</li><li>出：下标为 left 的元素离开窗口，left++ ，记录此时带窗口大小 i-left+1，为下一个循环做准备。</li></ul></li><li><p>求子数组个数</p><ul><li>越短越合法
一般要写 ans += right - left + 1。内层循环结束后，[left, right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left, right]，还有 [left+1, right],[left+2, right],…,[right, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left, left+1, left+2,…, right 的所有子数组都是满足要求的，这一共有 right−left+1 个。</li><li>越长越合法
一般要写 ans += left。内层循环结束后，[left, right] 这个子数组是不满足题目要求的，但在退出循环之前的最后一轮循环，[left−1, right] 是满足题目要求的。由于子数组越长，越能满足题目要求，所以除了 [left−1, right]，还有 [left−2, right],[left−3, right],…,[0, right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 0,1,2,…, left−1 的所有子数组都是满足要求的，这一共有 left 个。我们关注的是 left−1 的合法性，而不是 left。</li></ul></li><li><p>恰好型滑动</p></li></ul><table><thead><tr><th>维度</th><th>（至多≤）</th><th>（至少≥）</th><th></th></tr></thead><tbody><tr><td>函数目标</td><td>统计和≤x 的子数组数</td><td>统计和≥x 的子数组数</td><td></td></tr><tr><td>相减逻辑</td><td>用 “相邻小范围” 抠除（k 和 k-1）</td><td>用 “相邻大范围” 抠除（k 和 k+1）</td><td></td></tr><tr><td>窗口收缩条件</td><td>sum > x（保证窗口内 sum≤x）</td><td>sum ≥x（收缩到 sum&lt;x）</td><td></td></tr><tr><td>计数方式</td><td>ans += r-l+1（窗口长度）</td><td>ans += l（左边界位置）</td><td></td></tr><tr><td>核心逻辑</td><td>正向：直接统计≤x</td><td>反向：统计≥x</td><td></td></tr></tbody></table><h1 id=记录>记录<a hidden class=anchor aria-hidden=true href=#记录>#</a></h1><h2 id=定长处理>定长处理<a hidden class=anchor aria-hidden=true href=#定长处理>#</a></h2><ul><li><p>力扣：<a href=https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/>1456. 定长子串中元音的最大数目</a></p><ul><li>套用之前所给的解题思路即可，按照入—更新—出，标准三步就行。</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/maximum-average-subarray-i/>643. 子数组最大平均数 I</a></p><ul><li>同样思路，只不过从子数组中的元音字母个数改成了平均数。</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/>1343. 大小为 K 且平均值大于等于阈值的子数组数目</a></p><ul><li>本题只是对643 题求取的结果进行了筛选</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/>2379. 得到 K 个黑块的最少涂色次数</a></p><ul><li>与 1456 相似，遇到 w，进入窗口，然后更新，出窗口，最后返回最小值。</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/>2841. 几乎唯一子数组的最大和</a></p><ul><li>与 1343 相似，从大于等于阈值的数变成最大而已。</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/>2461. 长度为 K 子数组中的最大和</a></p><ul><li>变式，要求我们子数组中的元素不相同，且求取最大值。题643 加上附加条件。之前我们一般使用变量来存储信息，本体改用 map 存储。我们对 key 的 value 进行入——更新——出的操作。（注意 map 的操作方法）</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/>1423. 可获得的最大点数</a></p><ul><li>题643变式，逆向思维。我们求拿去之后剩下子数组的最小和。再用最大和减去即可。</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/minimum-discards-to-balance-inventory/>3679. 使库存平衡的最少丢弃次数</a></p><ul><li>题 2461 变式，加上阅读理解干扰。</li><li>如果我们仿照 2461 题，大概的结果如下，但结果是不对的。</li><li>原因是：>m 的c在未来要离开窗口，但由于已经丢弃，不能在后续离开窗口时修改，否则会破坏数组索引连续性，导致窗口边界无法准确定位。因此改用“虚拟标记”实现软删除：被丢弃的元素仅标记为特定值（如0），后续统计频率或处理窗口滑动时，只要碰到该标记就判定为无效元素，不纳入频率计算。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>minArrivalsToDiscard</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arrivals</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>m</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=err>；</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arrivals</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=p>;</span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=o>-</span><span class=n>w</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>map</span><span class=p>.</span><span class=na>merge</span><span class=p>(</span><span class=n>arrivals</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>,</span><span class=n>1</span><span class=p>,</span><span class=n>Integer</span><span class=p>::</span><span class=n>sum</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=o>&lt;</span><span class=w> </span><span class=n>0</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=n>map</span><span class=p>.</span><span class=na>getOrDefault</span><span class=p>(</span><span class=n>num</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>m</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>idx</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>//这里有问题</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>getOrDefault</span><span class=p>(</span><span class=n>num</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>num</span><span class=p>,</span><span class=n>c</span><span class=o>-</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=k>else</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>map</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>num</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arrivals</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>getOrDefault</span><span class=p>(</span><span class=n>out</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>m</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>idx</span><span class=o>--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>out</span><span class=p>,</span><span class=n>c</span><span class=o>-</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=k>else</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>map</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>out</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ans</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//正确思路</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>minArrivalsToDiscard</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>arrivals</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>m</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>cnt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>arrivals</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>arrivals</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// x 进入窗口</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cnt</span><span class=p>.</span><span class=na>getOrDefault</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>m</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// x 的个数已达上限</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 注意 x 在未来要离开窗口，但由于已经丢弃，不能在离开窗口时修改 cnt</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 这里直接置为 0，未来离开窗口就是 cnt[0]--，不影响答案</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>arrivals</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=c1>// 丢弃 arrivals[i]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>ans</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cnt</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 左端点元素离开窗口，为下一个循环做准备</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>1</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>w</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>left</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cnt</span><span class=p>.</span><span class=na>merge</span><span class=p>(</span><span class=n>arrivals</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=p>::</span><span class=n>sum</span><span class=p>);</span><span class=w> </span><span class=c1>// cnt[arrivals[left]]--</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ans</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><p>力扣： <a href=https://leetcode.cn/problems/grumpy-bookstore-owner/>1052. 爱生气的书店老板</a></p><ul><li>阅读理解+题 643 变式。</li><li>我们先求出在不生气是时间段的顾客数量，再把那时的顾客数量变为零，那么问题就转化为求一个窗口内最大数的问题了。有点和 3679 相似，本事给的数组也是可以利用的条件，可以用它来简化逻辑。</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/>3439. 重新安排会议得到最多空余时间 I</a></p><ul><li>抽象思维+题 643 变式+阅读理解</li><li>用一个数组记录其中有几个空闲时间段，求合并这些空闲时间段的最大数，又因为题目要求，这些空闲空闲时间段必然是连续合并，所以可以看成滑动窗口。</li><li>观察题目。题目就转化成了，有n+1 个空余时间段（空闲时间段可以为 0），合并其中<strong>连续</strong> k+1 个空余时间段，得到的最大长度是多少</li></ul></li></ul><h2 id=不定长-1>不定长<a hidden class=anchor aria-hidden=true href=#不定长-1>#</a></h2><h3 id=求最长>求最长<a hidden class=anchor aria-hidden=true href=#求最长>#</a></h3><ul><li>力扣：<a href=https://leetcode.cn/problems/longest-substring-without-repeating-characters/>3. 无重复字符的最长子串</a><ul><li>有点类似题 2461 变式，都是要求不重复的，不过字符用数组记录就行了。余下的按照正常的不定长处理方法就可以了。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>lengthOfLongestSubstring</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>toCharArray</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>cnt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>128</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>S</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>char</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cnt</span><span class=o>[</span><span class=n>c</span><span class=o>]++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=p>(</span><span class=n>cnt</span><span class=o>[</span><span class=n>c</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>1</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cnt</span><span class=o>[</span><span class=n>S</span><span class=o>[</span><span class=n>left</span><span class=o>]]--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>left</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>max</span><span class=p>(</span><span class=n>ans</span><span class=p>,</span><span class=n>i</span><span class=o>-</span><span class=n>left</span><span class=o>+</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ans</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><p>力扣： <a href=https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/>3090. 每个字符最多出现两次的最长子字符串</a></p><ul><li>同第题 3一样，不过由>1 变成 >2</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/>1493. 删掉一个元素以后全为 1 的最长子数组</a></p><ul><li>题 3 稍微变式，换种角度来开就是，我们只用记录 0 个数即可，当 0 个数>2 时，滑动窗口就行。</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/minimum-removals-to-balance-array/>3634. 使数组平衡的最少移除数目</a></p><ul><li>类似题 1423，逆向思维+排序。</li><li>排序之后，我们所求子数组很简单，找到其最大元素是最小元素 k 倍的最长那一个数组就行了。又因为排序，可以利用最大元素是最小元素 k 倍进行左移动和找到最大的范围（ps：不需要右指针移动，因为排序，左指针移动整体结果一定是增大的）</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/get-equal-substrings-within-budget/>1208. 尽可能使字符串相等</a></p><ul><li>题 643 不定长的一个变式，换种角度看，就是给定一个数组，求其值满足 target 的最长子数组。</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/fruit-into-baskets/>904. 水果成篮</a></p><ul><li>阅读理解+题 3 变式。我们只需要求一个只包含两个不同数的最长子数组即可。</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/maximum-erasure-value/>1695. 删除子数组的最大得分</a></p><ul><li>题 3 变式，变化了一下，不用求 i-left+1 最大了，直接不同元素的最大子数组和即可。</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/>2958. 最多 K 个重复元素的最长子数组</a></p><ul><li>题 3 变式，由 1 变成 k</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/>2024. 考试的最大困扰度</a></p><ul><li>阅读理解+题 1943 变式，算两次，一次求包含最少T 最长子数组，一次求 F。两者取更大。</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/max-consecutive-ones-iii/>1004. 最大连续1的个数 III</a></p><ul><li>题 2024 简单化了，只用算一次了，求一次求包含最少 0 的最长子数组</li></ul></li><li><p>力扣： <a href=https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/>2730. 找到最长的半重复子字符串</a></p><ul><li>题 3 变式，一个变两个。本题关键在于元素的更新处理，我们需要的只是在它不相同的时候递增 left 即可。（注意 i 的起始范围）</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/>2779. 数组的最大美丽值</a></p><ul><li>阅读理解+排序+转换</li><li>找最长的连续子数组，其最大值减最小值 ≤2k。由于排序后数组是有序的，相当于子数组的最后一个数减去子数组的第一个数 ≤2k。（ps：思维游戏）</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>maximumBeauty</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Arrays</span><span class=p>.</span><span class=na>sort</span><span class=p>(</span><span class=n>nums</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>nums</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>nums</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>2</span><span class=o>*</span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>left</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>max</span><span class=p>(</span><span class=n>ans</span><span class=p>,</span><span class=n>i</span><span class=o>-</span><span class=n>left</span><span class=o>+</span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ans</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>力扣： <a href=https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/>1658. 将 x 减到 0 的最小操作数</a><ul><li>逆向思维+题 1695 变式。</li></ul></li></ul><h3 id=求最短>求最短<a hidden class=anchor aria-hidden=true href=#求最短>#</a></h3><ul><li><p>力扣： <a href=https://leetcode.cn/problems/minimum-size-subarray-sum/>209. 长度最小的子数组</a></p><ul><li>题 1695 变式，Max 换 min</li></ul></li><li><p>力扣：<a href=https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/>2904. 最短且字典序最小的美丽子字符串</a></p><ul><li>题 3039 变式+元素处理。不考虑字典序的话基本差不多即 1 的个数>k。（ps: 感觉这种没啥办法，调库记忆处理方式）</li></ul></li></ul><h3 id=求子数组个数>求子数组个数<a hidden class=anchor aria-hidden=true href=#求子数组个数>#</a></h3><ul><li><p><strong>越短越合法</strong></p></li><li><p>力扣：<a href=https://leetcode.cn/problems/subarray-product-less-than-k/>713. 乘积小于 K 的子数组</a></p><ul><li>与之前的差不多，只不过最后的 max/min 。ans +=i-left+1;</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>numSubarrayProductLessThanK</span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>nums</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=p>(</span><span class=n>k</span><span class=o>&lt;=</span><span class=n>1</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>cnt</span><span class=w> </span><span class=o>=</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>&lt;</span><span class=n>nums</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cnt</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=n>nums</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=p>(</span><span class=n>cnt</span><span class=w> </span><span class=o>&gt;=</span><span class=n>k</span><span class=w> </span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=n>cnt</span><span class=w> </span><span class=o>/=</span><span class=w> </span><span class=n>nums</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=n>left</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ans</span><span class=w> </span><span class=o>+=</span><span class=n>i</span><span class=o>-</span><span class=n>left</span><span class=o>+</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ans</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>力扣：<a href=https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/>3258. 统计满足 K 约束的子字符串数量 I</a><ul><li>题 713 变式。（ps：元素处理小技巧）</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=w>  </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>cnt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>cnt</span><span class=o>[</span><span class=n>nums</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>1</span><span class=o>]--</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><ul><li><p>力扣：<a href=https://leetcode.cn/problems/1GxJYY/>LCP 68. 美观的花束</a></p><ul><li>阅读理解+题 713 变式。包装了一下而已，其他不变。</li></ul></li><li><p><strong>越长越合法</strong></p></li><li><p>力扣：<a href=https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/>1358. 包含所有三种字符的子字符串数目</a></p><ul><li>和越短越合法的基本没区别。ans += left。</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>numberOfSubstrings</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>char</span><span class=o>[]</span><span class=w> </span><span class=n>S</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=na>toCharArray</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>ans</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>left</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>Character</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>map</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=sc>&#39;b&#39;</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=sc>&#39;c&#39;</span><span class=p>,</span><span class=w> </span><span class=n>0</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>S</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>map</span><span class=p>.</span><span class=na>merge</span><span class=p>(</span><span class=n>S</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=p>::</span><span class=n>sum</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=sc>&#39;a&#39;</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=sc>&#39;b&#39;</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=sc>&#39;c&#39;</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>map</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>S</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>map</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>S</span><span class=o>[</span><span class=n>left</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>left</span><span class=o>++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>             </span><span class=n>ans</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>left</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ans</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li><p>力扣： <a href=https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/>2962. 统计最大元素出现至少 K 次的子数组</a></p><ul><li>题 1358 变式，基本一样>0 变成>k</li></ul></li><li><p><strong>恰好型滑动窗口</strong></p></li><li><p>力扣：<a href=https://leetcode.cn/problems/binary-subarrays-with-sum/>930. 和相同的二元子数组</a></p><ul><li>算两次相减即可。</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/cs/>CS</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/miit-6.s081/><span class=title>Next »</span><br><span>MIT 6.s081 2025 Fall 实验记录</span></a></nav></footer></article></main><aside id=toc-container class="toc-container wide"><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%9b%9e%e9%a1%be aria-label=回顾>回顾</a></li></ul></div></details></div></aside><script>let activeElement,elements;document.addEventListener("DOMContentLoaded",function(){if(checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),elements.length>0){activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")}const t=document.getElementById("top-link");t&&t.addEventListener("click",e=>{e.preventDefault(),window.scrollTo({top:0,behavior:"smooth"})})},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{const e=window.pageYOffset||document.documentElement.scrollTop;if(e===0)return;elements&&elements.length>0&&(activeElement=Array.from(elements).find(t=>{if(getOffsetTop(t)-e>0&&getOffsetTop(t)-e<window.innerHeight/2)return t})||activeElement,elements.forEach(e=>{const n=encodeURI(e.getAttribute("id")).toLowerCase(),t=document.querySelector(`.inner ul li a[href="#${n}"]`);if(e===activeElement){t.classList.add("active");const e=document.querySelector(".toc .inner"),n=t.offsetTop,s=e.clientHeight,o=t.clientHeight,i=n-s/2+o/2;e.scrollTo({top:i,behavior:"smooth"})}else t.classList.remove("active")}))},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script></body></html>